<!--
    Powered By nodeppt - This is probably the best web presentation tool so far!
    version: config.version
    site: config.site
    date: 
-->
<!doctype html>
<html>
<head>
    <meta charset="UTF-8">
    <title>C 结构体 - By </title>
    <link rel="stylesheet" media="all" href="./css/nodeppt.css">
    <link rel="stylesheet" media="only screen and (max-device-width: 480px)" href="./css/phone.css">
    
    <link rel="stylesheet" href="./js/highlight/styles/xcode.css">
    <link rel="stylesheet" href="./css/font-awesome.css">
    
<link rel="stylesheet" href="./css/theme.light.css">
</head>
<body>
<div class="slides">
    <slides id="container">
        <slide class="slide"><section class="slide-wrapper"><article class="flexbox vcenter">
<h1>C 结构体与共用体</h1>
<h2>Struct</h2>
<p>--</p>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article class="flexbox vcenter">
<h1>C 结构体</h1>
<p>C 数组允许定义可存储相同类型数据项的变量，结构是另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。 结构用于表示一条记录，假设您想要跟踪图书馆中书本的动态，您可能需要跟踪每本书的下列属性：</p>
<ul>
<li>Title</li>
<li>Author</li>
<li>Subject</li>
<li>Book ID</li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article class="flexbox vcenter">
<h1>定义结构</h1>
<p>为了定义结构，您必须使用 <code>struct</code> 语句。<code>struct</code> 语句定义了一个包含多个成员的新的数据类型，<code>struct</code> 语句的格式如下：</p>
<pre><code class="c">struct [structure tag] {
   member definition;
   member definition;
   ...
   member definition;
} [one or more structure variables];
</code></pre>
<p><code>structure tag</code>是可选的，每个<code>member definition</code> 是标准的变量定义，比如 <code>int i</code>; 或者 <code>float f</code>; 或者其他有效的变量定义。在结构定义的末尾，最后一个分号之前，您可以指定一个或多个结构变量，这是可选的。</p>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article class="flexbox vcenter">
<h1>结构体声明范例</h1>
<p>下面是声明 Book 结构的方式：</p>
<pre><code class="c">struct Books {
   char  title[50];
   char  author[50];
   int   book_id;
} book;
</code></pre>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article class="flexbox vcenter">
<h1>不完整结构</h1>
<p>结构类型无法把自己作为成员类型，但可以包含  <code>指向自己类型</code>  的指针成员。</p>
<pre><code class="c">struct list_node {
    struct list_node* prev;
    struct list_node* next;
    void* value;
};
</code></pre>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article class="flexbox vcenter">
<h1>不完整结构的定义</h1>
<p>定义不完整结构类型，只能使用小标签，像下面这样的 <code>typedef</code> 类型名称是不行的。</p>
<pre><code class="c">typedef struct {
    list_node* prev;
    list_node* next;
    void* value;
} list_node;

//编译出错:
$ make
gcc -Wall -g -c -std=c99  -o main.o main.c
main.c:15: error: expected specifier-qualifier-list before &#39;list_node&#39;
</code></pre>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article class="flexbox vcenter">
<h1>必须结合起来用</h1>
<pre><code class="c">typedef struct node_t {
    struct node_t* prev;
    struct node_t* next;
    void* value;
} list_node;

typedef struct node_t  { // 小标签可以和 typedef 定义的类型名相同
    struct node_t* prev;
    struct node_t* next;
    void* value;
} node_t;
</code></pre>
<blockquote>
<p>目前C99已结支持无小标签的结构体定义</p>
</blockquote>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article class="flexbox vcenter">
<h1>匿名结构</h1>
<p>在结构体内部使用匿名结构体成员，也是一种很常见的做法。</p>
<pre><code class="c">#include &lt;stdio.h&gt;
typedef struct {
  struct {
    int length;
    char chars[100];
  } s;
  int x;
} data_t;

int main(int argc, char * argv[]) {
  data_t d = { .s.length = 100, .s.chars = &quot;abcd&quot;, .x = 1234 };
  printf(&quot;%d\n%s\n%d\n&quot;, d.s.length, d.s.chars, d.x);
  return 0;
}
</code></pre>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article class="flexbox vcenter">
<h1>多种灵活的定义方式。</h1>
<pre><code class="c">int main() {
  /* 直接定义结构类型和变量 */
  struct { int x; short y; } a = { 1, 2 }, a2 = {};
  printf(&quot;a.x = %d, a.y = %d\n&quot;, a.x, a.y);

  /* 函数内部也可以定义结构类型 */
  struct data { int x; short y; };
  struct data b = { .y = 3 };
  printf(&quot;b.x = %d, b.y = %d\n&quot;, b.x, b.y);

  /* 复合字⾯面值 */
  struct data* c = &amp;(struct data){ 1, 2 };
  printf(&quot;c.x = %d, c.y = %d\n&quot;, c-&gt;x, c-&gt;y);

  /* 也可以直接将结构体类型定义放在复合字⾯面值中 */
  void* p = &amp;(struct data2 { int x; short y; }){ 11, 22 };

  /* 相同内存布局的结构体可以直接转换 */
  struct data* d = (struct data*)p; 
  printf(&quot;d.x = %d, d.y = %d\n&quot;, d-&gt;x, d-&gt;y);
}
输出:
a.x = 1, a.y = 2
b.x = 0, b.y = 3
c.x = 1, c.y = 2
d.x = 11, d.y = 22
</code></pre>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article class="flexbox vcenter">
<h1>初始化</h1>
<p>结构体的初始化和数组一样简洁方便，包括使用初始化器初始化特定的某些成员。未被初始化器初始化的成员将被设置为 0。</p>
<pre><code class="c">typedef struct {
  int x;
  short y[3];
  long long z;
} data_t;

int main() {
  data_t d = {};
  data_t d1 = { 1, { 11, 22, 33 }, 2LL };
  data_t d2 = { .z = 3LL, .y[2] = 2 };
  return 0;
}
//结果:
d = {x = 0, y = {0, 0, 0}, z = 0}
d1 = {x = 1, y = {11, 22, 33}, z = 2}
d2 = {x = 0, y = {0, 0, 2}, z = 3}
</code></pre>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article class="flexbox vcenter">
<h1>弹性结构成员</h1>
<p>通常又称作  <code>不定长结构</code> ，就是在结构体尾部声明一个未指定长度的数组。
用 <code>sizeof</code> 运算符时，该数组未计入结果。</p>
<pre><code class="c">typedef struct string {
    int length;
    char chars[];
} string;

int main() {
  int len = sizeof(string) + 10;     // 计算存储⼀一个 10 字节⻓长度的字符串（包括 \0）所需的⻓长度。
  char buf[len];                     // 从栈上分配所需的内存空间。
  string *s = (string*)buf;          // 转换成 struct string 指针。
  s-&gt;length = 9;     
  strcpy(s-&gt;chars, &quot;123456789&quot;);
  printf(&quot;%d\n%s\n&quot;, s-&gt;length, s-&gt;chars);

  return 0;
}
</code></pre>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article>
<p>考虑到不同编译器和 ANSI C 标准的问题，也用 <code>char chars[1]</code> 或 <code>char chars[0]</code> 来代替。
对这类结构体进行拷贝的时候，尾部结构成员不会被复制。</p>
<pre><code class="c">int main() {
  int len = sizeof(string) + 10; 
  char buf[len];

  string *s = (string*)buf;
  s-&gt;length = 10;
  strcpy(s-&gt;chars, &quot;123456789&quot;);

  string s2 = *s; ! ! ! ! ! // 复制 struct string s。
  printf(&quot;%d\n%s\n&quot;, s2.length, s2.chars); ! // s2.length 正常，s2.chars 就悲剧了。
  return 0;
}
</code></pre>
<blockquote>
<p>而且不能直接对弹性成员进行初始化。</p>
</blockquote>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article class="flexbox vcenter">
<h1>访问结构成员</h1>
<p>为了访问结构的成员，我们使用成员访问运算符<code>.</code>。成员访问运算符是结构变量名称和我们要访问的结构成员之间的一个句号。您可以使用 <code>struct</code> 关键字来定义结构类型的变量。下面的实例演示了结构的用法：</p>
<pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
struct Books {
   char  title[50];
   char  author[50];
   int   book_id;
};

int main( ) {
   struct Books tBook;
   strcpy( tBook.title, &quot;C Programming&quot;);
   strcpy( tBook.author, &quot;Nuha Ali&quot;); 
   tBook.book_id = 6495407;

   printf( &quot;Book title : %s\n&quot;,   tBook.title);
   printf( &quot;Book author : %s\n&quot;,  tBook.author);
   printf( &quot;Book book_id : %d\n&quot;, tBook.book_id);

   return 0;
}
//它会产生下列结果：
Book title : C Programming
Book author : Nuha Ali
Book book_id : 6495407
</code></pre>
<p>--</p>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article class="flexbox vcenter">
<h1>结构作为函数参数</h1>
<p>您可以把结构作为函数参数，传参方式与其他类型的变量或指针类似。</p>
<pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

struct Books {
   char  title[50];
   char  author[50];
   int   book_id;
};

/* 函数声明 */
void printBook( struct Books book );
int main( ) {
   struct Books tBook; 
   strcpy( tBook.title, &quot;C Programming&quot;);
   strcpy( tBook.author, &quot;Nuha Ali&quot;); 
   tBook.book_id = 6495407;

   printBook( tBook );
   return 0;
}
void printBook( struct Books tBook ) {
   printf( &quot;Book title : %s\n&quot;,   tBook.title);
   printf( &quot;Book author : %s\n&quot;,  tBook.author);
   printf( &quot;Book book_id : %d\n&quot;, tBook.book_id);
}

//它会产生下列结果：
Book title : C Programming
Book author : Nuha Ali
Book book_id : 6495407
</code></pre>
<p>--</p>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article class="flexbox vcenter">
<h1>指向结构的指针</h1>
<p>您可以定义指向结构的指针，方式与定义指向其他类型变量的指针相似，如下所示：</p>
<pre><code class="c">struct Books *struct_pointer;
</code></pre>
<p>可以在上述定义的指针变量中存储结构变量的地址。为了查找结构变量的地址，请把<code>&amp;</code>运算符放在结构名称前面，如下所示：</p>
<pre><code class="c">struct_pointer = &amp;Book1;
</code></pre>
<p>为了使用指向该结构的指针访问结构的成员，您必须使用 <code>-&gt;</code> 运算符，如下所示：</p>
<pre><code class="c">struct_pointer-&gt;title;
</code></pre>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article class="flexbox vcenter">
<h1>使用结构指针实现</h1>
<pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

struct Books {
   char  title[50];
   char  author[50];
   int   book_id;
};

void printBook( struct Books *ptBook ) {
   printf( &quot;Book title : %s\n&quot;,   ptBook -&gt; title);
   printf( &quot;Book author : %s\n&quot;,  ptBook -&gt; author);
   printf( &quot;Book book_id : %d\n&quot;, ptBook -&gt; book_id);
}

int main( ) {
   struct Books tBook;
   strcpy( tBook.title, &quot;C Programming&quot;);
   strcpy( tBook.author, &quot;Nuha Ali&quot;); 
   tBook.book_id = 6495407;
   printBook( &amp;tBook );
   return 0;
}
//它会产生下列结果：
Book title : C Programming
Book author : Nuha Ali
Book book_id : 6495407
</code></pre>
<p>--</p>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article class="flexbox vcenter">
<h1>综合范例</h1>
<pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;

struct Person {
  char *pName;
  int iAge;
};

struct Person *initPerson(char *pName, int iAge) {
  struct Person *pt = malloc(sizeof(struct Person));
  assert(pt != NULL);
  pt-&gt;pName = malloc(50*sizeof(char));
  strcpy(pt-&gt;pName, pName);
  pt-&gt;iAge = iAge;
  return pt;
}

//print person data
void printPerson(struct Person *pt) {
  printf(&quot;\tName is: %s\n&quot;, pt-&gt;pName );
  printf(&quot;\tAge is: %d\n&quot;,pt-&gt;iAge );
}

//free person memory
void desoryPerson(struct Person *pt) {
  assert(pt != NULL);
  free(pt-&gt;pName);
  free(pt);
}

int main() {
  struct Person *ptPerson = initPerson(&quot;frank&quot;,24);
  printPerson(ptPerson);
  desoryPerson(ptPerson);
}
</code></pre>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article class="flexbox vcenter">
<h1>C 共用体</h1>
<p>共用体是一种特殊的数据类型，允许您在相同的内存位置存储不同的数据类型。您可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值。共用体提供了一种使用相同的内存位置的有效方式。</p>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article class="flexbox vcenter">
<h1>定义共用体</h1>
<p>为了定义共用体，您必须使用 <code>union</code> 语句，方式与定义结构类似。<code>union</code> 语句定义了一个新的数据类型，带有多个成员。<code>union</code> 语句的格式如下：</p>
<pre><code class="c">union [union tag] {
   member definition;
   member definition;
   ...
   member definition;
} [one or more union variables];
</code></pre>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article>
<p><code>union tag</code> 是可选的，每个<code>member definition</code>是标准的变量定义，比如 <code>int i</code>; 或者 <code>float f</code>; 或者其他有效的变量定义。在共用体定义的末尾，最后一个分号之前，您可以指定一个或多个共用体变量，这是可选的。</p>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article>
<p>下面定义一个名为 <code>Data</code> 的共用体类型，有三个成员<code>i</code>、<code>f</code>和<code>str</code>：</p>
<pre><code class="c">union Data {
   int i;
   float f;
   char  str[20];
} data;
</code></pre>
<p><code>Data</code> 类型的变量可以存储一个整数、一个浮点数，或者一个字符串。这意味着一个变量（相同的内存位置）可以存储多个多种类型的数据。您可以根据需要在一个共用体内使用任何内置的或者用户自定义的数据类型。</p>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article>
<p>共用体占用的内存应足够存储共用体中最大的成员。例如，在上面的实例中，<code>Data</code> 将占用 20 个字节的内存空间，因为在各个成员中，字符串所占用的空间是最大的。下面的实例将显示共用体占用的总内存大小：</p>
<pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
union Data {
   int i;
   float f;
   char  str[20];
};

int main() {
   union Data uData;        
   printf( &quot;Memory size occupied by data : %ld\n&quot;, sizeof(uData));
   return 0;
}

//它会产生下列结果：
Memory size occupied by data : 20
</code></pre>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article class="flexbox vcenter">
<h1>访问共用体成员</h1>
<p>为了访问共用体的成员，我们使用成员访问运算符.。成员访问运算符是共用体变量名称和我们要访问的共用体成员之间的一个句号。您可以使用 <code>union</code> 关键字来定义共用体类型的变量。</p>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article class="flexbox vcenter">
<h1>共用体的用法：</h1>
<pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

union Data {
   int i;
   float f;
   char  str[20];
};

int main( ) {
   union Data uData;        
   uData.i = 10;
   uData.f = 220.5;
   strcpy( uData.str, &quot;C Programming&quot;);
   printf( &quot;data.i : %d\n&quot;, uData.i);
   printf( &quot;data.f : %f\n&quot;, uData.f);
   printf( &quot;data.str : %s\n&quot;, uData.str);
   return 0;
}

//它会产生下列结果：
data.i : 1917853763
data.f : 4122360580327794860452759994368.000000
data.str : C Programming
</code></pre>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article>
<p>在这里，我们可以看到共用体的<code>i</code>和<code>f</code>成员的值有损坏，因为最后赋给变量的值占用了内存位置，这也是 str 成员能够完好输出的原因。</p>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article class="flexbox vcenter">
<h1>使用共用体的目的</h1>
<p>再看一个相同的实例，这次在同一时间只使用一个变量</p>
<pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

union Data {
   int i;
   float f;
   char  str[20];
};

int main( ) {
   union Data uData;        
   uData.i = 10;
   printf( &quot;data.i : %d\n&quot;, uData.i);
   uData.f = 220.5;
   printf( &quot;data.f : %f\n&quot;, uData.f);
   strcpy( uData.str, &quot;C Programming&quot;);
   printf( &quot;data.str : %s\n&quot;, uData.str);
   return 0;
}

//它会产生下列结果：
data.i : 10
data.f : 220.500000
data.str : C Programming
</code></pre>
<p>在这里，所有的成员都能完好输出，因为同一时间只用到一个成员。</p>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article class="flexbox vcenter">
<h1>使用指针操作结构体范例1</h1>
<pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;

typedef struct {
  int   id;
  char  *name;
} Book;

Book* initBook(int id, char *name) {
  Book *tmp = (Book *)malloc(sizeof(Book));
  tmp-&gt;name = (char*)malloc(sizeof(char)*50);
  tmp -&gt; id = id;
  strcpy(tmp -&gt; name, name);
  printf(&quot;init book successful!\n&quot;);
  return tmp;
}

void printBook(Book *book) {
  printf(&quot;%d\n&quot;, book-&gt;id );
  printf(&quot;%s\n&quot;, book-&gt;name );
}

int main( ) {
  Book *book;
  book = initBook(12, &quot;liyang&quot;);
  printBook(book);
  return 0;
}
</code></pre>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article class="flexbox vcenter">
<h1>使用指针操作结构体范例2</h1>
<pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;

typedef struct {
  int   id;
  char  *name;
} Book;

void initBook(Book **book, int id, char *name) {
  *book = (Book *)malloc(sizeof(Book));
  (*book)-&gt;name = (char*)malloc(sizeof(char)*50);
  (*book) -&gt; id = id;
  strcpy((*book) -&gt; name, name);
  printf(&quot;init book successful!\n&quot;);
}

void printBook(Book *book) {
  printf(&quot;%d\n&quot;, book-&gt;id );
  printf(&quot;%s\n&quot;, book-&gt;name );
}

void freeBook(Book *book) {
  free(book-&gt;name);
  book-&gt;name = NULL;
  free(book);
  book = NULL;
}

int main( ) {
  Book *book;
  initBook(&amp;book, 12, &quot;liyang&quot;);
  printBook(book);
  freeBook(book);

  return 0;
}
</code></pre>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article class="flexbox vcenter">
<h1>课堂练习</h1>
<p>1 . 要求使用结构体实现新闻查询系统如下：</p>
<ul>
<li>定义新闻结构，包括 <code>序号id</code>、<code>新闻标题</code>、<code>新闻内容</code>、<code>作者</code>、<code>发布时间</code></li>
<li>通过键盘输入3条新闻数据</li>
<li>编写函数 <code>searchNews</code> ,查询满足 <code>keyword</code> 的新闻记录，返回该新闻 <code>id</code> ；</li>
<li>编写函数 <code>printNews</code>, 打印对于 id的新闻内容，其格式如下：</li>
</ul>
<pre><code class="bash"># 查询新闻
int searchNews(char * keyword);

# 打印新闻
void printNews(int id);

# 新闻输出格式
----------------------------------------------------------------
| zhang                                         2018-11-22 7:36|
----------------------------------------------------------------
|                            title                             |
----------------------------------------------------------------
|                           content                            |
----------------------------------------------------------------
</code></pre>

</article></section></slide>
        

        <!-- <slide class="slide logoslide dark nobackground">
            <article class="flexbox vcenter">
                <h2 style="color: white;">Powered By nodeppt vconfig.version</h2>
            </article>
        </slide> -->
        <div class="slideTip" id="tip"></div>
    </slides>
</div>
<canvas id="drawBoard" class="draw-board" width="900" height="700"></canvas>
<div class="progress"><span id="progress"></span></div>
<div id="_buttons">
    <div class="_btn-box" id="_btn-box" style="display:none;">
        <button class="fa fa-arrow-circle-left" id="_btn-prev"></button>
        <button class="fa fa-arrow-circle-right" id="_btn-next"></button>
        <button class="fa fa-paint-brush" id="_btn-brush"></button>
        <button class="fa fa-compress" id="_btn-overview" data-toggle="fa fa-expand"></button>
    </div>
    <button class="fa fa-bars" id="_btn-bar"  data-toggle="fa fa-close"></button>
</div>
<script src="./js/mixjs/lib/mix.0.3.0.min.js"></script>
<script>
    var ASSET_RELATIVE_DIR = ".";
</script>
<script>
var base = location.protocol + '//' + location.host;

var path = (location.pathname + '#').split('/').filter(function(v){
    return !!v;
});
path.pop();
path = path.join('/');
if (typeof ASSET_RELATIVE_DIR === 'string') {
    path = path + '/' + ASSET_RELATIVE_DIR;
}
MixJS.config({
    baseURL: [ base, path, 'js'].join('/')+'/'
});

</script>
<script src="./js/mixjs/lib/event/broadcast.js"></script>
<script src="./js/nodeppt.js"></script>
<script>
Slide.init({
    containerID: 'container',
    drawBoardID: 'drawBoard',
    slideClass: '.slide',
    buildClass: '.build',
    progressID: 'progress',
    transition: 'move',
    width: 1100,
    dir: './',
    
    //打开下面的注释就开启postMessage方式
    //访问网址127.0.0.1:8080/ppt/demo#client
    control:{
        type: 'postMessage',
        args:{
            isControl:  false
        }
    },
    
    tipID: 'tip'
});
MixJS.loadJS('highlight/highlight.pack.js',function(){
    hljs.tabReplace = '  ';
    hljs.initHighlightingOnLoad();
});
</script>


<!--placeholder-->
</body>
</html>

title: C 语言圣战
theme: light

[slide]
# C语言圣战
## Story of C Language

[slide]    
# 和Borland的缘由
SideKick: 在大学时第一个在PC上使用的软件，Borland也是以SideKick成为全球知名的软件公司。  
TurboPascal： 我大二，大三撰写作业的最爱，几乎所有的作业都是使用TurboPascal完成的，奠立Borland创业基业的软件。

[slide]    
# TurboPascal的故事
当年PhilippeKahn和Anders到美国创业时，由Anders以汇编语言撰写了TurboPascal的编译器，而Philippe则完成了其它的部份。开发完TurboPascal之后，穷得快连登广告的钱都没有了。但是为了在Byte杂志刊登TurboPascal的广告，因此商量了一个方法，一天他们约了Byte杂志的人到当时Borland的办公室讨论刊登广告的事情。

[slide]   
当Byte的人到了Borland之后，Philippe，Anders和公司的助理小姐故意忙着接电话，接受TurboPascal的订单，并且告诉Byte杂志的人等一下。过了一阵子之后Philippe才进入房间向Byte的人道歉，说他们的TurboPascal受到市场的热烈欢迎，订单源源不断的到来，因此可能不需要在Byte杂志刊登广告了，接着Philippe向Byte的人展示TurboPascal这个产品。由于在当时的机器中TurboPascal能够在少少的RAM中常驻执行，又提供闪电般的编译速度，立刻让Byte杂志的人震惊在当场，凭着专业知识和丰富的经验，Byte的人也立刻知道这将是一个革命性的软件，因此马上希望Philip能够在Byte杂志刊登TurboPascal的广告，并且愿意以半价刊登。当然，Philip也立刻的答应了，于是一个革命性的软件TurboPascal终于在Byte杂志刊登出来了，售价49.99美元的TurboPascal立刻为Borland带来了大量的财富，TurboPascal也立刻的成为PC上除了基本的Basic之外最畅销的开发工具，也正式揭开了Borland影响PC开发工具10几年的序幕。


[slide]    
# MicrosoftPascal & TurboBasic
MicrosoftPascal: 它和TurboPascal的确是有一段差距，我使用了一次之后便把它丢到垃圾桶。  
TurboBasic: 非常的棒，编译速度就和TurboPascal一样，是一个非常有前途的产品。我听说Microsoft和Borland互相交换条件，Microsoft不进入Pascal的市场，而Borland则退出Basic的市场。它只有1.0之后便和MicrosoftPascal一样消失了。

[slide]    
# TurboC
Borland推出了风行天下的TurboC编译器，当然，从此之后TurboC便成了不离身的工具，而Borland也藉由TurboC这第三项畅销产品迈向了世界前10名的项尖软件公司。

[slide]    
# C语言历程
1. 第一个使用的C++编译器则是ZortechC/C++，这家公司稍后被Symantec收购成为SymantecC/C++的核心。
2. Borland也推出了TurboC/C++1.0这第一个C/C++编译器，但是在我和ZortechC/C++比较之后，还是觉得ZortechC/C++比较好，因此就继续使用ZortechC/C++。
3. 直到Borland的TurboC/C++2.0编译器推出之后，才逐渐成为C/C++语言的王者，而我也像以往一样把ZortechC/C++换成了TurboC/C++。
4. 在1991年Microsoft推出了MicrosoftC/C++6.0以及MFC1.0，因为没有图形整合发展环境，还是在DOS下的整合发展环境，而且MFC1.0以非常不好用，而且编译器产生的程序代码效率不好，甚至会产生错误的程序代
码。
5. 在MicrosoftC/C++6.0不久之后，Borland终于推了BC++3.0。而这套软件也开启了Borland雄霸C/C++编译器常达5,6年之久的序幕。

[slide]    
# BC++3.0
BC++3.0推出之后由于拥有第一个在Window下的稳定的图形整合发展环境，而且它产生的最佳化程序代码也是MicrosoftC/C++6.0望尘莫及的，因此很快的几乎所有的C/C++程序员转而使用BC++3.0。因此在那个时候有一个现象，那就是几乎所有的公用程序或是Shareware都是使用BC++开发的，许多硬件厂商的驱动程序也是使用BC++3.0来撰写的。


[slide]   
Borland在BC++3.0获得空前的胜利之后，并没有松懈下来，因为Borland知道BC++3.0还缺了一个最重要的胜利因子，那就是如同Microsoft的MFC一样的C/C++的Framework，因为Borland也看出了Framework将会是未来C/C++产品中最重要的一环科技。不过Borland此时面临了一个重要的十字路口，那就是到底要自己开发一个和MFC抗衡的Framework，还是要如何做。因为如果要自己开发Framework，那么势必要花上一些时间，但是Borland想趁BC++3.0如虹的气势再下一城，以便彻底击溃MicrosoftC/C++。因此最后Borland决定向一家叫WhiteWater的公司购买一套由这家公司开发的一个Framework，这套Framework便是后来鼎鼎大名的OWL的源流。而Borland也因为向WhiteWater购买了这套Framework，因而也引进了一个日后非常重要的人物，那就是后来负责开发Delphi的一员大将ZackUrlocker。

1992年Borland也进入了最巅峰的时期，因为Borland推出了BC++3.1。


[slide]    
# C/C++的光荣战役

在Borland购买下WhiteWater的C++Framework之后，便更命为OWL(ObjectWindowLibrary)，并且很快的推出了以OWL1.0为核心的BC++3.1。由于OWL比当时的MFC1.0封装的更为完整和好用，再加入ResourceWorkshop可视化能力，以及BC++3.1自己最强劲的编译器和整合发展环境，因此立刻的风靡了全世界，其受欢迎的程度更是远远的超过了它的前一版本BC++3.0。由于BC++3.1的畅销，立刻让Borland在C/C++市场一举击溃了MicrosoftC/C
++，市场占有率超过了50%，是全球第一的C/C++产品，也把Borland推上了最高峰，成为全世界第三大的软件公司。

[slide]   
接着Borland又计划推出Windows版的Pascal，不过在Borland开发Borland Pascal For Windows时，当时最具盛名的Charles就说除了C/C++之外，Borland不可能做出能够在Windows下执行的Pascal，不过很明显的，即使是WindowsAPI的大师Charles也错了。Borland不但做出来了，而且Borland Pascal For Windows还非常的畅销，当然Borland Pascal For Windows也是后来Delphi的根基。

[slide]   
当时的Borland可说是不可一世，不但产品大卖，而且日进斗金。Borland在ScottsValley豪华的总部也是在那个时候由PhilippeKahn大手笔的花了一亿多美金搭建的。不过也许是Borland太成功了，因此也开始让PhilippeKahn渐渐的养成了好大喜功，目中无人的态度，也种下了Borland开始走向衰退的因子。


[slide]    
# Borland的没落
在BC++3.1大获成功之后，Borland却开始松懈了下去，并且开始走下坡。

当然这有许多的原因，最主要的原因是Philippe和当时BC++的产品经理EugeneWang闹翻了。EugeneWang是一位非常聪明的中国人，他一手把BC带到了世界第一的地位，并且BC3.1成功之后有了更伟大的想法，那就是在下一个版本中完整的以OWL封装所有的WindowsAPI，因为OWL1.0尚未完整的封装所有Windows的API。此外还计划以OWL为核心，开发一个类似今日Borland C++Builder的以可视化组件为开发方式的开发工具。如果在当时Borland能够开发出这种C开发工具，就不会再有Microsoft的VisualC++了。

[slide]   
不过很不幸的是，EugeneWang稍后和PhilippeKahn发生了争执，EugeneWang一气之下离开了Borland。而PhilippeKahn则认为BC的地位已不可动摇，因此没有立刻的做下一版的BC,这样一拖竟然浪费将近2年的时间。EugeneWang在离开Borland之后，立刻的被Symantec所网罗，稍后他非常短的时间之内开发出了著名的Symantec C/C++（拥有最棒的整合发展环境和最有创意的C/C++开发工具）。

[slide]    
# Microsoft VisualC/C++崛起
MicrosoftVisualC/C++1.0在BC3.1推出2年之后推出，并且立刻获得市场好评。不但在编译器方面能够和BC++3.1相抗衡，在整合发展环境方面更大幅领先了BC++3.1，还能够自动产生MFC的程序代码，再也不是昔日的吴下阿蒙。直到此时PhilippeKahn才从梦中惊醒而急于开发下一代的BC++4.0，但是为时已晚，开发工具市场从此就开始逐渐的被Microsoft蚕食了。


[slide]    
# Microsoft的挖角技术
Microsoft的VisualC/C++小组有60%的成员是从Borland挖来的，这个举动不但立刻的让Borland流失了大量的优秀技术人才，也在数年之后造成了Borland控告Microsoft的导火线。


[slide]    
# Borland技术工程师CarlQuinn

CarlQuinn在MicrosoftVisualC/C++1.0推出之后，立刻奉命开发一个能够和MFC相抗衡的全新OWL，而CarlQuinn也是数年后JBuilder的JBCLFramework的灵魂开发人物。CarlQuinn不但负责开发OWL，也为Borland在组件Framework的技术领域立下了重要的贡献。由于CarlQuinn的投入，因此开启了OWL大战MFC，BC++缠斗VisualC/C++数年精彩好戏的序幕。


[slide]    
# BC++的反击


当VisualC++1.0在C/C++开发工具市场获得了空前成果的之后，Borland才从BC++3.1的胜利梦中惊醒，思考如何面对VisualC++的猛烈功势。事实上当时的Borland如果脑袋清醒一点，好好看清当时C/C++开发工具的市场，那么Borland应该会发现虽然VisualC++经过2年多的整军经武，实力已经大不前。

[slide]   
不过BorlandC/++3.1仍然在许多方面可以和VisualC++一争长短的。  
1. VisualC++的最佳化编译器仍然落后BC++3.1  
2. MFC仍然没有完整的封装WindowAPI，而且MFC是以较低阶的方式封装WindowAPI，并不是很对象导向，也不是很容易使用。  
3. VisualC++当时并没有很好的封装数据结构的ContainerClass，而BC却有非常好用的BIDS类别库。  
4. 最重要的是BC++3.1仍然拥有绝大的市场，而且几乎所有的外围公用程序，如果Borland不要急，好好的开发下一代的C/C++ 开发工具，即使Microsoft Visual C++能够掠夺一些市场占有率，但是如果下一代的BC++能够像BC++3.0一样立刻拉开和VisualC/C++的距离，那么Borland在C/C++ 市场仍将拥有王者的地位。


[slide]   
1. 失去了许多的人材，EugeneWang也离开了;
2. 近3年的时间之内，几乎没有持续的开发;
3. 这么短的时间内决定全新发展整合开发环境;
4. 把OWL完全重写；
5. 大幅修改最佳化编译器；
6. VBX让16位和32位的程序能够同时使用16位。


[slide]   
上面所说的每一项都是大工程，Borland早应该在BC++3.1之后便开始做这些工作，现在要在短短的一年多的时间内重新开发一个这么复杂的C/C++开发工具，几乎是不可能的工作。但是在PhilippeKahn的要求之下，这些Borland的工程师还是硬着头皮做了出来。



[slide]    
# 痛失江山的BC++4.0
C++3.1后的4年，Borland终于推出了新一代的BorlandC/++4.0，这个肩负和VisualC++1.0对抗的C/C++开发工具。刚推出之后订单的确如雪片般飞来，销售情形非常好，因为这毕竟是Borland在睽违了数年之后的大作，许多Borland的用户都迫不及待的升级。
但是在推出一段时间之后，市场的反应就急速的冷却下来，因为各种负面的批评不断涌现，这主要的原因当然是BC4实在太差了。


[slide]   
1. 整合发展环境方面-bug太多，容易当掉而且反应速度缓慢
2. 编译器方面-最佳化玩得过火，产生错误的编译程序代码
3. OWL方面-采用全新的多重继承架构，虽然是正确的做法，却和BC++3.1中的OWL不兼容，造成许多程序员无法升级C/C++项目
4. VBX方面-大胆的采用在16/32位都能使用VBX的技术，造成一些VBX无法顺利的在BC++4.0中使用
5. OWL2.0做了从基本架构的改变，导致程序升级代价太大。



[slide]    
# 流失的市场
在BC++4.0失利之后，立刻造成了严重的后果：
1. 首先是BC++的市场大量且快速的流失，让VisualC/C++快速的成长。  
2. 当初BC++3.1在公用程序市场打下的江山也拱手让人，原本许多硬件厂商也使用BC++3.0/3.1撰写驱动程序也开始转换到VC/C++。  
3. 严重的是在应用程序市场方面由于4.0的品质以及稍后OLE的关系，也开始大量的开始转为使用VC/C++来撰写应用程序。  

Borland在3个主要的应用市场接连败退，C/C++的江山注定将易主，其势已不可挽。

[slide]    
# BC++，VisualC/C++，WatcomC/C++和SymantecC/C++的缠斗

自BC/C++4.0一役大败之后，VC/C++固然在不断的接收BC/C++失去的市场，此时在C/C++市场上也加入了另外两个坚强的对手，那就是SymantecC/C++和WatcomC/C++。

[slide]    
# SymantecC/C++的发展史

SymantecC/C++（SC）的ThinkC/C++在Macintosh上便是非常有名的编译器，因此早在C/C++领域便有深厚的基础。在Symantec并购了ZortechC/C++之后，只缺一个在PC上有丰富经验的开发工具领导者。正好此时EugeneWang离开了Borland，于是Symantec立刻重金招揽EugeneWang。

[slide]   
在1993年左右吧，Symantec推出了第一个SC版本，立刻便获得了市场的好评。自此之后不断的改善，也逐渐的获得了不小的C/C++市场，隐然成为可以对抗BC和VC的另一山头。当时SC是以最华丽，先进的整合发展环境获得市场的高度认同，在C/C++编译器最佳化方面的表现也不会输给其它的编译器。

[slide]    
# WatcomC/C++的发展史

非常有趣的是，WatcomC/C++（WC）走的路子和SymantecC/C++几乎是完全相反的。当时出品WC编译器的是一家加拿大的小公司，不过这家公司却对最佳化编译器有深入的研究。当时WC是以在DOS下能够产生最好的最佳化程序代码闻名于世的，在其时有许多写游戏和DOSExtender的厂商都是指名要使用WC，因为不论是BC或是VC产生的最佳化程序代码都比WC的最佳化程序代码差上一截。再加入当时最有名的DOS Extender 厂商 PharLap 公司也是使用WC，因此WC在专业的C/C++程序员以及系统程序员心中是第一品牌的C/C++开发工具。

[slide]   
在WatcomC/C++于DOS市场占稳了脚步之后，由于Window已经逐渐成为市场的主流，DOS势必将被逐渐淘汰出局，因此WatcomC/C++要继续的生存下去，也一定要推出Window平台的C/C++开发工具。1994年Watcom终于推出第一个Window的开发工具，但是WC在Window推出的C/C++开发工具实在是平凡不已，其开发环境和另外三个对手比较起来简直像是远古的产品，一点特色都没有，不过WC仍然是当时最好的编译器，因此在当时发生了一个非常有趣的现象，就是许多软件公司会同时买 BC/VC/SC 之一， 再搭配一套WC。在开发时使用其它三套工具之一，最后要出货时再使用WC来编译以产生最佳的程序代码。因此它也成为四大C/C++开发工具之一。后来被Sybase并购成为Optima++的前身。

[slide]    
# PharLap公司
Andrew Schulman（首席工程师）： 《Undocumented Windows》的作者，Microsoft要告 AndrewSchulman。Matt Pietrek： 巨著《Windows Internals》；著名的Window除错工具SoftIce，BoundsChecker的主要研发工程师。Matt本身是Borland的Turbo Debugger小组工作。当时TurboDebugger是DOS下最强的除错工具，即使是Microsoft也无法推出能够和TurboDebugger抗衡的除错工具。后来TurboDebugger小组的部份成员被Microsoft挖走，让Microsoft掌握了Borland的核心除错技术，以致后来也能够推出不错的除错工具。

[slide]    
# 关键的时刻 - MFC Or OWL

在SC和WC逐渐的站稳了脚步之后，四大编译器决战的时刻也逐渐逼近了。在1994年未的决战之前，Symantec和Watcom同时面对了一个非常严厉的考验，那就是C/C++Framework的选择。


[slide]   
虽然Symantec和Watcom都以各自的特色占得了市场，不过在当时对于一个C/C++ 开发工具来说，最重要的因素之一就是C/C++Framework。因此Symantec和Watcom也都必须提供使用者一套C/C++Framework。不过这对于Symantec和Watcom都是一个难以解决的问题，因为当时的C/C++Framework已由Borland的OWL和Microsoft的MFC所占领，如果要自己发展新的C/C++Framework，那么Symantec和Watcom并没有如此雄厚的资源，也无法在短时间之内完成。因此Symantec和Watcom必须下一个决定到底是要使用MFC或是OWL做为它们的开发工具C/C++Framework。


[slide]   
在1993年初Symantec和Watcom分别和Microsoft签约LicenseMFC做为它们的开发工具的C/C++ Framework。至此大势以定，在C/C++ Framework的市场已经形成三家夹击一家的形式。当时许多人便预估Borland将成为输家，因为市场已经成为一面倒，MFC看起来已经是胜券在握了。在当时于Borland的内部也展开了激烈的辩论，讨论是否也要LicenseMFC做为C/C++的Framework，停止继续开发OWL。不过后来Borland还是决定继续开发OWL，而不使用MFC，因为Borland的C/C++ 技术小组认为MFC不论是在架构上或是设计上都比不上OWL。而且由于VC在当时对于C/C++的标准支持不如BC/C++，因此在MFC内部使用了大量的Macro以及不标准的语法，因此如果BC要使用MFC，那么还需要修改编译器来编译MFC。到了1994年未，C/C++开发工具的四大天王决战的日子终于愈来愈近了。

[slide]    
# OLE的搅局

不知道是时运不济或是Microsoft的刻意如此，在1994年BC和VC决战的前夕，Microsoft推出了OLE技术。OLE是Microsoft为了对抗Apple的文件技术以及IBMOS2的Workplace和文件技术应运而生的。OLE可以让Window平台的文件能够内嵌在不同的应用程序中并且能够让文件在应用程序中被即地编辑(In-PlaceEditing)。说实在的，OLE虽然是失败的技术，而且Apple/IBM的文件技术也都失败了，但是OLE却足以成为Borland，Symantec和Watcom失败的重要因素。

[slide]   
EX. Word的文件能够内嵌在Excel之中，双击Word文件立刻可以打开Word编辑。当时只有Microsoft有该功能，其它的厂商例如Lotus，WordPerfect等都无法实作出这种功能。虽然后来公司也也推出了具备OLE功能的应用程序(容易死机)，但是慢了许久流失了市场。

[slide]   
由于OLE功能复杂，因此Borland无法立刻实现这种功能，于是就造成了市场上负面的影响。至于Symantec和Watcom的License的只是MFC1.x的版本，而OLE功能是在MFC2.0中实现的（20000多行程序代码），而且MFC2.0却仅限于VC使用，就是这关键的一点让其它三家厂商吃了亏。


[slide]   
对于OLE这个关键技术的影响，Borland是深知在心的，因此在计划在BC4.5的OWL2.5中支持OLE。当时Borland推出的解决方案便是OCF(Object Component Framework)。


[slide]   
Borland当初在设计OCF时有几个重大的目标。这些目标包括了:   
1. 如何能够使得OLE琐碎、复杂的接口能够单纯化;
2. 如何能够使得OLE在窗口环境下写程序的思考方式一致化「事件驱动」。
3. 如何能够在微软占尽天时、地利的情况下使得Borland的产品具备OLE的功能。
4. 如何能够让大多数C++的程序员都能够享受OLE的功能而不局限于OWL的程序员。

由于上述的设计目标,而造就了典雅而具有弹性的OCF。由于OCF本身是一完整而独立的Framework,因此它可适用于各种应用程序发展Framework。

[slide]    
# C/C++开发工具的最后圣战
1995初Borland在痛定思痛之后，终于清除了BC++4.0中所有的问题，也开发出了自BC++3.1以来最稳定，最快速的BC++4.5的版，准备和Microsoft决一死战。

[slide]   
首先当Symantec和Watcom分别取得了MFC之后，Symantec便推出了C/C++7.x的版本，和WC混战了起来。两个使用系出同门的C/C++Framework产品战得不亦乐乎，随后BC4.5和VC的新版本也加入了这场最重要的决战。但是让Symantec和WatcomC大吃一惊的是Microsoft使用的MFC居然比它们的版本高出了一个版本(1.x对2.x)，而且新版本的MFC包含了完整的OLE支持能力。而Borland虽然也有OCF，但是仍然不敌新版MFC中的OLE能力。由于当时几乎所有的应用程序都需要支持OLE，但是却只有使用VC最新的版本才能够开发完整OLE能力的应用程序，因此不管OLE到底有没有用，反正先加入再说。因此市场上的情势很快的就发生了巨大的变化，几乎大部份的应用程序开发因为OLE的原因都选择使用VC，Symantec和Watcom军团很快的就败阵下来。

[slide]   
至于BC4.5虽然是一流的产品，如果没有OLE的因素，VC新版本真的并没有比4.5好。虽然4.5也有OCF，但是在市场上只有Borland和Novell，WordPerfect选择使用OCF，在和Microsoft的VC++经过将近一年的缠斗之后，其它大部份的厂商都选择了Microsoft的MFC2.x版，真是形势比人强。基本上OCF的架构真的是个好东西，只是OCF无法完整的支持OLE，因为OLE的发展是掌握在Microsoft手中，因此虽然OCF的架构良好，终究在功能上不及对手。Microsoft 结合操作系统，开发工具和应用程序的手段真是无往不利。击败Lotus，Borland是如此，歼灭Netscape也是如此。

[slide]   
对于Symantec和Watcom来说，这场战役就如同『长平之战』，秦军坑杀40多万赵军一样。杀得Symantec和Watcom全军覆没，大败而归，至此Symantec弃受PC的C/C++开发工具市场，转而开始研发Java开发工具，进而在稍后推出了著名的Visual Cafe,至于EugeneWang则离开了Symantec，自此也离开了PC开发工具的领域。而Watcom则是更为凄惨，整个公司在DOS的市场逐渐式微，而Window平台的开发工具又大败而归，两头落空。不久之后Watcom便被新兴而起的Sybase并购，从此消失于竞争激烈的市场。

[slide]   
归纳Symantec和Watcom失败的原因是C/C++的FrameworkMFC掌握在Microsoft手中，在决战时刻Microsoft居然手握比Symantec和Watcom更新的MFC利器，而且在VC整合最佳开发环境之后，Symantec和Watcom所有的优势完全被Microsoft封死。因此在产品，技术，市场和气势上完全不如对手的情形下，自然只能任人宰割了。

[slide]   
对于Borland而言，虽然没有像Symantec和Watcom那么溃不成军，但也是再次败下阵来。虽然平心而论BC4.5的确是一个非常好的产品，无论在OWL，最佳化编译器，整合发展环境方面都有一流的表现，和BC4.0比较起来简直有如脱胎换骨一般。

[slide]   
但是无奈当初BC4.0给人挥之不去的负面印象，以及无法完整支持当时如火如荼的OLE技术，因此还是在决战之中败了下来。好在蓝色的Borland大军毕竟是训练有素的，虽然自此让Microsoft占据了超过50%的市场，成为C/C++开发工具的老大，但是Borland仍然掌握了超过30%的市场，稍做喘息，并且支撑Borland在各重要战役失败之后维持公司的运作，等待Delphi的浴火重生，再重新出发。经过这一役之后，Microsoft终于清除了大部份的对手，对于Microsoft而言程序语言开发工具的战争已经结束，这个市场注定将被Microsoft占据大部份的市场。在Microsof手握操作系统，Office软件和开发工具三大获利市场之后，Microsoft也开始将矛头对准下两个竞争目标，关连数据库以及主从架构开发工具。在Microsoft正式进军这两个市场之后，当然也展开了连番的好戏，尤其是在主从架构开发工具方面又开启了VB，PowerBuilder，Gupta/Centura和Delphi的惊天动地大会战。另外一个意外开启的战争则是Microsoft在1995年和Netscape的挑起的浏览器大战。

[slide]   
对于Borland而言，在C/C++最后一役之后，开发工具的圣战已然结束，Borland也正式开始走下坡。更严重的是自此之后Borland不但丧失了C/C++的江山，也失去了对于C/C++开发工具的创意。

[slide]    
# IBM VisualC/C++

IBM在C/C++开发工具扮演的角色一直令人啼笑皆非，因为在C/C++编译器战争最激烈的时刻，IBM这个全球信息大厂却一直是缺席的。一直到了1995之后，C/C++编译器市场大势已定之后才慢慢的加入战局，推出VisualAgeC++3.0，企图进攻此市场。但是此时市场早已由Microsoft的VisualC/C++称雄。IBM的VisualAge虽然以创新的可视化设计家能够定义对象之间的关系，但是在其它方面却乏善可陈，整个整合发展环境也缓慢如蜗牛，需要非常高文件的硬件配备才能够顺利的执行，和VisualC/C++以及BC++等工具比较起来就像是恐龙一般，因此几乎没有在市场上引起任何的反应。在IBM推出VisualAge3.0并没有在PC的C/C++开发工具市场获得任何的明显成果之后，IBM又再次的集中了许多的资源，开发下一代3.5的版本，希望能够在此市场占有一定的比率。

[slide]   
IBM的C/C++开发工具之所以在市场无法成功是一是因为并不了解在此竞争激烈的市场中使用者到底要什么。另外一个原因则因为IBM并不以PC上的开发工具软件为重要的事业，即使无法竞争对于IBM来说也没有什么影响，不像Borland这可是生命之争。因此IBM只是兴起玩玩，随即放下。所以我觉得在PC平台使用IBM的工具是很危险的，因为IBM可能随时会放弃此市场。例如不知道现在VisualAgeC/C++到底如何，是不是还在3.5或是4.0版，已经数年没有任何的维护和改善了。

[slide]   
稍后IBM为了想在OS2和Window平台上推出能够和Microsoft相抗衡的Basic工具，因此秘密的研发了一个ObjectBasic。我也曾看过这个工具，但是ObjectBasic跑起来慢得跟乌龟一样．后来不知道是不是一直无法改善这个问题，因此IBM从没有推出此产品，现在IBM似乎只对Java有兴趣，VisualAgeForJava还算发展的不错，希望不会有一天IBM对VisualAgeForJava的态度会和VisuaAgeForC/C++以及ObjectBasic一样才好．

[slide]    
# 快速殒落的潜力之星－Sybase的C/C++RAD工具Optima++
在1996年吧，Sybase并购了Watcom之后，终于推出了石破天惊的C/C++开发工具，Optima++。Optima++是当结合了Watcom的最佳化编译器以及类似Delphi的组件拖曳开发环境的第一个RADC/C++开发工具，更棒的是Optima++的组件架构(类似Delphi的VCL)完全是以纯正的C/C++程序代码撰写的。这可不得了，因为这代表Optima++是一个融合了VC和Delphi两大王者开发工具为一身的超级赛亚人工具。Optima++很快在开始风卷市场，虽然没有立刻的占据很大的市场量，但是已经造成了一股气势，开始为VC和Delphi带来了压力。


[slide]   
但是Optima++在1.5推出之后就可能会停止发行新版本了，而且最大的中文问题也没有解决。因为Sybase要把资源移去为当时愈来愈红的Java研发一个新的JavaRAD开发工具，那就是后来的PowerJ（当时Borland开始了
JBuilder的研发）。


[slide]   
C/C++的开发工具之争到此算是告一段落了，虽然后来Borland继续推出了BC++5.0但是品质仍然不够好，市场反应也不佳，后来Borland终于在BC++5.02之后宣布停止此条产品线的开发，BC++的光荣历史也就从此打止，真是令人不胜感叹，而VC从此在C/C++ 开发工具市场中再也没有对手。 不过没有竞争的市场的确会让人松懈的， 后来的VC进步的幅度愈来愈小， MFC也数年没有什么大进步，不像当时和BC++竞争时每一个版本都有大幅的改善。看来寡占的市场的确是不好的。


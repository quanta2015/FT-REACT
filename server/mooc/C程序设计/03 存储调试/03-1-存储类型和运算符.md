title: 存储类型和运算符
theme: light

[slide]
# 存储类型和运算符
## operator and storage

[slide]
# C 存储类
存储类定义 C 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C 程序中可用的存储类：
- auto
- register
- static
- extern

[slide]
# auto 存储类
`auto` 存储类是所有局部变量默认的存储类。  
```c
{
   int mount;
   auto int month;
}
```
上面的实例定义了两个带有相同存储类的变量，`auto` 只能用在函数内，即 `auto` 只能修饰局部变量。

[slide]
# register 存储类
`register` 存储类用于定义存储在寄存器中而不是 `RAM` 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 `'&'` 运算符（因为它没有内存位置）。


[slide]
```c
  register int  miles;
```
寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 `'register' `并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。

[slide]
# static 存储类
`static` 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 `static` 修饰局部变量可以在函数调用之间保持局部变量的值。


[slide]
`static` 修饰符也可以应用于全局变量。当 `static` 修饰全局变量时，会使变量的作用域限制在声明它的文件内。
在 C 编程中，当 `static` 


[slide]
用在类数据成员上时，会导致仅有一个该成员的副本被类的所有对象共享。
```c
#include <stdio.h>
static int count = 5; /* 全局变量 */
void func( void ) {
   static int i = 5; /* 局部静态变量 */
   i++;
   printf("i is %d and count is %d\n", i, count);
}
void main() {
   while(count--) {
      func();
   }
}
//产生下列结果：
i is 6 and count is 4
i is 7 and count is 3
i is 8 and count is 2
i is 9 and count is 1
i is 10 and count is 0
```

[slide]
# 静态和隐藏
- 隐藏性：static 变量只在定义它的范围内可见，在其他范围内不可见。如果你把一个static 变量定义在一个函数内，那么只有这个函数可以读写它，其他函数对它不可见。如果你把它定义在一个.c 文件中，那么只有这个.c 文件中的函数可以读写它，其他的.c 文件中对这个变量不可见。
- 静态存储区：修饰函数时，这个函数只在当前的`.c` 文件中可见，这样我们就可以在不同的`.c`文件中定义同名的函数，而不会引起冲突，只要其中的一个函数用`static` 来修饰



[slide]
# extern 存储类
`extern` 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。  

- 使用 `'extern'` 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。  
- 有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 `extern` 来得到已定义的变量或函数的引用。  
- `extern` 是用来在另一个文件中声明一个全局变量或函数。  

`extern` 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候，


[slide]
如下所示：第一个文件：main.c
```c
#include <stdio.h>
int count ;
extern void write_extern();
main() {
   count = 5;
   write_extern();
}
```


[slide]
第二个文件：support.c
```c
#include <stdio.h>
extern int count;
void write_extern(void) {
   printf("count is %d\n", count);
}
```


[slide]
在这里，第二个文件中的 `extern` 关键字用于声明已经在第一个文件 **main.c** 中定义的 `count` 。  
现在 ，编译这两个文件，如下所示：
```c
 $gcc main.c support.c
```
这会产生 a.out 可执行程序，当程序被执行时，它会产生下列结果：
```c
5
```

[slide]
# C 运算符
运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。C 语言内置了丰富的运算符，并提供了以下类型的运算符：

- 算术运算符
- 关系运算符
- 逻辑运算符
- 位运算符
- 赋值运算符
- 杂项运算符


[slide]
算术运算符
下表显示了 C 语言支持的所有算术运算符。假设变量 A 的值为 **10**，变量 B 的值为 **20**，则：

|运算符	|描述	|实例|
|--|--	|:--|
|+  |实例把两个操作数相加	|A + B 将得到 30|
|-	|实例从第一个操作数中减去第二个操作数	|A - B 将得到 -10|
|*	|实例把两个操作数相乘	|A * B 将得到 200|
|/	|实例分子除以分母	|B / A 将得到 2|
|%	|实例取模运算符，整除后的余数	|B % A 将得到 0|
|++	|实例自增运算符，整数值增加 1	|A++ 将得到 11|
|--	|实例自减运算符，整数值减少 1	|A-- 将得到 9|


[slide]
# 实例
请看下面的实例，了解 C 语言中所有可用的算术运算符：
```c
#include <stdio.h>
main() {
   int a = 21;
   int b = 10;
   int c ;
   c = a + b;
   printf("Line 1 - c 的值是 %d\n", c );
   c = a - b;
   printf("Line 2 - c 的值是 %d\n", c );
   c = a * b;
   printf("Line 3 - c 的值是 %d\n", c );
   c = a / b;
   printf("Line 4 - c 的值是 %d\n", c );
   c = a % b;
   printf("Line 5 - c 的值是 %d\n", c );
   c = a++; 
   printf("Line 6 - c 的值是 %d\n", c );
   c = a--; 
   printf("Line 7 - c 的值是 %d\n", c );
}
//它会产生下列结果：
Line 1 - c 的值是 31
Line 2 - c 的值是 11
Line 3 - c 的值是 210
Line 4 - c 的值是 2
Line 5 - c 的值是 1
Line 6 - c 的值是 21
Line 7 - c 的值是 22
```

[slide]
# 关系运算符
下表显示了 C 语言支持的所有关系运算符。假设变量 A 的值为 **10**，变量 B 的值为 **20**，则：

| 运算符 | 描述                                                           | 实例              |
|--------|----------------------------------------------------------------|-------------------|
| ==     | 检查两个操作数的值是否相等，如果相等则条件为真。               | (A == B) 不为真。 |
| !=     | 检查两个操作数的值是否相等，如果不相等则条件为真。             | (A != B) 为真。   |
| >      | 检查左操作数的值是否大于右操作数的值，如果是则条件为真。       | (A > B) 不为真。  |
| <      | 检查左操作数的值是否小于右操作数的值，如果是则条件为真。       | (A < B) 为真。    |
| >=     | 检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。 | (A >= B) 不为真。 |
| <=     | 检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。 | (A <= B) 为真。   |


[slide]
# 实例
请看下面的实例，了解 C 语言中所有可用的关系运算符：
```c
#include <stdio.h>
main() {
   int a = 21;
   int b = 10;
   int c ;
   if( a == b ) {
      printf("Line 1 - a 等于 b\n" );
   } else {
      printf("Line 1 - a 不等于 b\n" );
   }
   if ( a < b ) {
      printf("Line 2 - a 小于 b\n" );
   } else {
      printf("Line 2 - a 不小于 b\n" );
   }
   if ( a > b ) {
      printf("Line 3 - a 大于 b\n" );
   } else {
      printf("Line 3 - a 不大于 b\n" );
   }
   /* 改变 a 和 b 的值 */
   a = 5;
   b = 20;
   if ( a <= b ) {
      printf("Line 4 - a 小于或等于 b\n" );
   }
   if ( b >= a ) {
      printf("Line 5 - b 大于或等于 b\n" );
   }
}
//它会产生下列结果：
Line 1 - a 不等于 b
Line 2 - a 不小于 b
Line 3 - a 大于 b
Line 4 - a 小于或等于 b
Line 5 - b 大于或等于 b
```

[slide]
# 逻辑运算符
下表显示了 C 语言支持的所有关系逻辑运算符。假设变量 A 的值为 **1**，变量 B 的值为 **0**，则：

| 运算符 | 描述    | 实例   |
|--------|---------|--------|
| && | 称为逻辑与运算符。如果两个操作数都非零，则条件为真。| (A && B) 为假。  |
| &#124;&#124;   | 称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。| (A &#124;&#124; B) 为真。  |
| !| 称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。 | !(A && B) 为真。 |


[slide]
# 实例
请看下面的实例，了解 C 语言中所有可用的逻辑运算符：
```c
#include <stdio.h>
main() {
   int a = 5;
   int b = 20;
   int c ;
   if ( a && b ) {
      printf("Line 1 - 条件为真\n" );
   }
   if ( a || b ) {
      printf("Line 2 - 条件为真\n" );
   }
   /* 改变 a 和 b 的值 */
   a = 0;
   b = 10;
   if ( a && b ) {
      printf("Line 3 - 条件为真\n" );
   } else {
      printf("Line 3 - 条件不为真\n" );
   }
   if ( !(a && b) ) {
      printf("Line 4 - 条件为真\n" );
   }
}
//它会产生下列结果：
Line 1 - 条件为真
Line 2 - 条件为真
Line 3 - 条件不为真
Line 4 - 条件为真
```

[slide]
# 位运算符
位运算符作用于位，并逐位执行操作。`&`、 `|` 和 `^` 的真值表如下所示：

| p | q | p & q | p &#124; q | p ^ q |
|---|---|-------|-------|-------|
| 0 | 0 | 0     | 0     | 0     |
| 0 | 1 | 0     | 1     | 1     |
| 1 | 1 | 1     | 1     | 0     |
| 1 | 0 | 0     | 1     | 1     |


[slide]
假设如果 `A = 60`，且 `B = 13`，现在以二进制格式表示，它们如下所示：

```
A = 0011 1100  
B = 0000 1101  
---------------
A&B = 0000 1100  
A|B = 0011 1101   
A^B = 0011 0001  
~A  = 1100 0011  
```


[slide]
下表显示了 C 语言支持的位运算符。假设变量 A 的值为 **60**，变量 B 的值为 **13**，则：

| 运算符 | 描述 | 实例|
|--------|-----|-----|
| &      | 如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。| (A & B) 将得到 12，即为 0000 1100|
| &#124;      | 如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。| (A &#124; B) 将得到 61，即为 0011 1101|
| ^      | 如果存在于其中一个操作数中但不同时存在于两个操作数中，二进制异或运算符复制一位到结果中。 | (A ^ B) 将得到 49，即为 0011 0001|
| ~      | 二进制补码运算符是一元运算符，具有"翻转"位效果。| (~A ) 将得到 -61，即为 1100 0011，2 的补码形式，带符号的二进制数。 |
| <<     | 二进制左移运算符。左操作数的值向左移动右操作数指定的位数。| A << 2 将得到 240，即为 1111 0000|
| >>     | 二进制右移运算符。左操作数的值向右移动右操作数指定的位数。| A >> 2 将得到 15，即为 0000 1111|



[slide]
# 实例
请看下面的实例，了解 C 语言中所有可用的位运算符：
```c
#include <stdio.h>
main() {
   unsigned int a = 60;	/* 60 = 0011 1100 */  
   unsigned int b = 13;	/* 13 = 0000 1101 */
   int c = 0;           
   c = a & b;       /* 12 = 0000 1100 */ 
   printf("Line 1 - c 的值是 %d\n", c );
   c = a | b;       /* 61 = 0011 1101 */
   printf("Line 2 - c 的值是 %d\n", c );
   c = a ^ b;       /* 49 = 0011 0001 */
   printf("Line 3 - c 的值是 %d\n", c );
   c = ~a;          /*-61 = 1100 0011 */
   printf("Line 4 - c 的值是 %d\n", c );
   c = a << 2;     /* 240 = 1111 0000 */
   printf("Line 5 - c 的值是 %d\n", c );
   c = a >> 2;     /* 15 = 0000 1111 */
   printf("Line 6 - c 的值是 %d\n", c );
}
//它会产生下列结果：
Line 1 - c 的值是 12
Line 2 - c 的值是 61
Line 3 - c 的值是 49
Line 4 - c 的值是 -61
Line 5 - c 的值是 240
Line 6 - c 的值是 15
```

[slide]
# 赋值运算符
下表列出了 C 语言支持的赋值运算符：

| 运算符   | 描述  | 实例  |
|-------- |-------  |
| =   | 简单的赋值运算符，把右边操作数的值赋给左边操作数  | C = A + B 将把 A + B 的值赋给 C   |
| +=  | 加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数  | C += A 相当于 C = C + A  |
| -=  | 减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数  | C -= A 相当于 C = C - A  |
| *=  | 乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数  | C *= A 相当于 C = C * A  |
| /=  | 除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数  | C /= A 相当于 C = C / A  |
| %=  | 求模且赋值运算符，求两个操作数的模赋值给左边操作数   | C %= A 相当于 C = C % A  |
| <<=   | 左移且赋值运算符  | C <<= 2 等同于 C = C << 2  |
| >>=   | 右移且赋值运算符  | C >>= 2 等同于 C = C >> 2  |
| &=  | 按位与且赋值运算符   | C &= 2 等同于 C = C & 2  |
| ^=  | 按位异或且赋值运算符  | C ^= 2 等同于 C = C ^ 2  |
| &#124;=  | 按位或且赋值运算符   | C &#124;= 2 等同于 C = C &#124; 2  |


[slide]
# 实例
请看下面的实例，了解 C 语言中所有可用的赋值运算符：
```c
#include <stdio.h>
main() {
    int a = 21;
    int c ;
    c =  a;
    printf("Line 1 - =  运算符实例，c 的值 = %d\n", c );
    c +=  a;
    printf("Line 2 - += 运算符实例，c 的值 = %d\n", c );
    c -=  a;
    printf("Line 3 - -= 运算符实例，c 的值 = %d\n", c );
    c *=  a;
    printf("Line 4 - *= 运算符实例，c 的值 = %d\n", c );
    c /=  a;
    printf("Line 5 - /= 运算符实例，c 的值 = %d\n", c );
    c  = 200;
    c %=  a;
    printf("Line 6 - %= 运算符实例，c 的值 = %d\n", c );
    c <<=  2;
    printf("Line 7 - <<= 运算符实例，c 的值 = %d\n", c );
    c >>=  2;
    printf("Line 8 - >>= 运算符实例，c 的值 = %d\n", c );
    c &=  2;
    printf("Line 9 - &= 运算符实例，c 的值 = %d\n", c );
    c ^=  2;
    printf("Line 10 - ^= 运算符实例，c 的值 = %d\n", c );
    c |=  2;
    printf("Line 11 - |= 运算符实例，c 的值 = %d\n", c );
}
//它会产生下列结果：
Line 1 - =  运算符实例，c 的值 = 21
Line 2 - += 运算符实例，c 的值 = 42
Line 3 - -= 运算符实例，c 的值 = 21
Line 4 - *= 运算符实例，c 的值 = 441
Line 5 - /= 运算符实例，c 的值 = 21
Line 6 - %= 运算符实例，c 的值 = 11
Line 7 - <<= 运算符实例，c 的值 = 44
Line 8 - >>= 运算符实例，c 的值 = 11
Line 9 - &= 运算符实例，c 的值 = 2
Line 10 - ^= 运算符实例，c 的值 = 0
Line 11 - |= 运算符实例，c 的值 = 2
```

[slide]
# 杂项运算符
下表列出了 C 语言支持的其他一些重要的运算符，包括 `sizeof` 和 `?` `:`

| 运算符 	| 描述 	| 实例 	|
|----------	|------------------	|--------------------------------------	|
| sizeof() 	| 返回变量的大小。 	| sizeof(a) 将返回 4，其中 a 是整数。 	|
| & 	| 返回变量的地址。 	| &a; 将给出变量的实际地址。 	|
| * 	| 指向一个变量。 	| *a; 将指向一个变量。 	|
| ? : 	| 条件表达式 	| 如果条件为真 ? 则值为 X : 否则值为 Y 	|

[slide] 
# 实例
请看下面的实例，了解 C 语言中所有可用的杂项运算符：
```c
#include <stdio.h>
main() {
    int a = 4;
    short b;
    double c;
    int *ptr;
    /* sizeof 运算符实例 */
    printf("Line 1 - 变量 a 的大小 = %d\n", sizeof(a) );
    printf("Line 2 - 变量 b 的大小 = %d\n", sizeof(b) );
    printf("Line 3 - 变量 c 的大小 = %d\n", sizeof(c) );
    /* & 和 * 运算符实例 */
    ptr = &a;   /* 'ptr' 现在包含 'a' 的地址 */
    printf("a 的值是 %d\n", a);
    printf("*ptr 是 %d\n", *ptr);
    /* 三元运算符实例 */
    a = 10;
    b = (a == 1) ? 20 : 30;
    printf( "b 的值是 %d\n", b );
    b = (a == 10) ? 20 : 30;
    printf( "b 的值是 %d\n", b );
}
//它会产生下列结果：
a 的值是 4
*ptr 是 4
b 的值是 30
b 的值是 20
```

[slide]
# C 中的运算符优先级
运算符的优先级确定表达式中项的组合，其决定一个表达式如何计算。在表达式中，较高优先级的运算符会优先被计算。


[slide]
某些运算符比其他运算符有更高的优先级，例如，乘除运算符具有比加减运算符更高的优先级。

> 例如 `x = 7 + 3 * 2`，在这里，x 被赋值为 **13**，而不是 **20**，因为运算符 `*` 具有比 `+` 更高的优先级，所以首先计算乘法 **3*2**，然后再加上 **7**。


[slide]
下表将按运算符优先级**从高到低**列出各个运算符，具有较高优先级的运算符出现在表格的上面，具有较低优先级的运算符出现在表格的下面。

| 类别  	| 运算符  	| 结合性  	|
|-------------	|-----------------------------------	|-----------	|
| 后缀  	| () [] -> . ++ - -   	| 从左到右  	|
| 一元  	| + - ! ~ ++ - - (type)* & sizeof  	| 从右到左  	|
| 乘除  	| * / %  	| 从左到右  	|
| 加减  	| + -  	| 从左到右  	|
| 移位  	| << >>  	| 从左到右  	|
| 关系  	| < <= > >=  	| 从左到右  	|
| 相等  	| == !=  	| 从左到右  	|
| 位与 AND  	| &  	| 从左到右  	|
| 位异或 XOR  	| ^  	| 从左到右  	|
| 位或 OR  	| &#124;  	| 从左到右  	|
| 逻辑与 AND  	| &&  	| 从左到右  	|
| 逻辑或 OR  	| &#124;&#124;  	| 从左到右  	|
| 条件  	| ?:  	| 从右到左  	|
| 赋值  	| = += -= *= /= %=>>= <<= &= ^= &#124;&#124;=  	| 从右到左  	|
| 逗号  	| ,  	| 从左到右  	|


[slide]
# 实例
请看下面的实例，了解 C 语言中运算符的优先级：
```c
#include <stdio.h>
main() {
    int a = 20;
    int b = 10;
    int c = 15;
    int d = 5;
    int e;
    e = (a + b) * c / d;      // ( 30 * 15 ) / 5
    printf("(a + b) * c / d 的值是 %d\n",  e );
    e = ((a + b) * c) / d;    // (30 * 15 ) / 5
    printf("((a + b) * c) / d 的值是 %d\n" ,  e );
    e = (a + b) * (c / d);   // (30) * (15/5)
    printf("(a + b) * (c / d) 的值是 %d\n",  e );
    e = a + (b * c) / d;     //  20 + (150/5)
    printf("a + (b * c) / d 的值是 %d\n" ,  e );
    return 0;
}
//它会产生下列结果：
(a + b) * c / d 的值是 90
((a + b) * c) / d 的值是 90
(a + b) * (c / d) 的值是 90
a + (b * c) / d 的值是 50
```



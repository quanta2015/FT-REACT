title: 索引设计概要
theme: light

[slide]
# 索引设计概要
## Index Optimize

[slide]
# 1.1 磁盘 IO
数据库中所有的数据其实都是以 `文件` 的形式存储在 `磁盘` 上的，而从磁盘上随机访问对应的数据非常耗时，所以数据库程序和操作系统提供了 `缓冲池` 和 `内存` 以提高数据的访问速度。

[slide]
数据读取不是以 `行` 为单位，无论是读取一行还是多行，都会将该行或者多行所在的 · 全部加载进来，然后再读取对应的数据记录；读取所耗费的时间与行数无关，只与页数有关。

![](../../img/cloud/index-opt01.png)

[slide]
1.2 随机读取
数据库等待一个页从磁盘读取到缓存池的，都需要消耗约 10ms 左右的时间。 10ms 的时间在计算领域其实是一个非常巨大的成本， 可以向SSD磁盘写入3MB数据，但是数据库程序在 10ms 之内只能将一页的数据加载到缓冲池中。



![](../../img/cloud/index-opt02.png)

[slide]
# 1.3 内存读取
如果在缓存池中没有找到对应的数据页，那么会去内存中寻找对应的页面：当对应的页面存在于内存时，数据库程序就会使用内存中的页，这能够将数据的读取时间降低一个数量级，将 10ms 降低到 1ms ；缓冲区和内存都失败了，最后就只能执行随机 IO 从磁盘中获取对应的数据页。

![](../../img/cloud/index-opt03.png)

[slide]
# 1.4 顺序读取
从磁盘读取数据并不是都要付出很大的代价，当数据库管理程序一次性从磁盘中顺序读取大量的数据时，读取的速度会异常的快，大概在 40MB/s 左右。

![](../../img/cloud/index-opt04.png)

[slide]
如果一个页面的大小为 `4KB` ，那么 `1s` 的时间就可以读取 `10000` 个页，读取一个页面所花费的平均时间就是 `0.1ms` ，相比随机读取的 `10ms` 已经降低了两个数量级，甚至比内存中读取数据还要快。

![](../../img/cloud/index-opt05.png)

[slide]
# 数据页面的顺序读取有两个非常重要的优势

- 同时读取多个界面意味着总时间的消耗会大幅度减少，磁盘的吞吐量可以达到  40MB/s；
- 数据库管理程序会对一些即将使用的界面进行预读，以减少查询请求的等待和响应时间；

[slide]
# 2.1 索引片 Index Slices
索引片其实就是 SQL 查询在执行过程中扫描的一个索引片段，在这个范围中的索引将被顺序扫描，根据索引片包含的列数不同，索引分为 `宽索引` 和 `窄索引` 。

对于查询 `SELECT id, username, age FROM users WHERE username="draven"`

- (id, username) ：窄索引，因为没有包含 age 列
- (id, username, age)：宽索引，包含全部数据列

![](../../img/cloud/index-opt06.png)


[slide]
宽索引能够避免二次的随机 IO，而`窄索引`就需要在对索引进行顺序读取之后再根据主键 `id` 从主键索引中查找对应的数据；对于`窄索引`，每一个在索引中匹配到的记录行最终都需要执行另外的随机读取从聚集索引中获得剩余的数据，如果结果集非常大，那么就会导致随机读取的次数过多进而影响性能。

[slide]
# 2.2 过滤因子
影响 SQL 查询的除了查询本身还与数据库表中的数据特征有关，如果使用的是`窄索引`那么对表的随机访问就不可避免，在这时如何让索引片变 `薄` 就是我们需要做的了。

[slide]
一个SQL查询扫描的索引片大小其实是由过滤因子决定的，也就是满足查询条件的记录行数所占的比例。 

![](../../img/cloud/index-opt07.png)

[slide]
对于users表来说，`sex= "male"` 就不是一个好的过滤因子，它会选择整张表中一半的数据，所以在一般情况下我们最好不要使用 `sex` 列作为整个索引的第一列；而 `name="draven"` 是一个比较好的过滤因子，它能过滤整个数据表中 `99.9%` 的数据；如果将三个过滤条件进行组合，创建一个新的索引 `(name, age, sex)` 并同时使用这三列作为过滤条件。

![](../../img/cloud/index-opt08.png)

[slide]
当三个过滤条件都是等值谓词时，几个索引列的顺序其实是无所谓的，索引列的顺序不会影响同一个 SQL 语句对索引的选择，也就是索引 `(name, age, sex)` 和 `(age, sex, name)` 对于上图中的条件来说是完全一样的，这两个索引在执行查询时都有着完全相同的效果。列与列之间不应该有太强的相关性，如果不同的列之间有相关性，那么得到的结果就会比直接乘积得出的结果大一些。比如：所在的城市和邮政编码就有非常强的相关性，两者的过滤因子直接相乘其实与实际的过滤因子会有很大的偏差，不过这在多数情况下都不是太大的问题。

[slide]
对于一张表中的同一个列，不同的值也会有不同的过滤因子，这也就造成了同一列的不同值最终的查询性能也会有很大差别： 

![](../../img/cloud/index-opt09.png)


[slide]
当我们评估一个索引是否合适时，需要考虑极端情况下查询语句的性能，比如 `0%` 或者 `50%` 等；最差的输入往往意味着最差的性能，在平均情况下表现良好的 SQL 语句在极端的输入下可能就完全无法正常工作，这也是在设计索引时需要注意的问题。

[slide]
总而言之，需要扫描的索引片的大小对查询性能的影响至关重要，而扫描的索引记录的数量，就是总行数与组合条件的过滤因子的乘积，索引片的大小最终也决定了从表中读取数据所需要的时间。

[slide]
# 2.3 匹配列与过滤列
假设在 `users表`中有 `name` 、 `age` 和 `(name, sex, age)` 三个辅助索引；当 WHERE 条件中存在类似 `age = 21` 或者 `name = "draven"`这种等值谓词时，它们都会成为匹配列 `(Matching Column)` 用于选择索引树中的数据行，但是当我们使用以下查询时：
```sql
SELECT * FROM users
WHERE name = "draven" AND sex = "male" AND age > 20;
```

[slide]
虽然` (name, sex, age) `索引包含了上述查询条件中的全部列，但是只有 `name` 和 `sex` 两列才是匹配列，在执行上述查询时，会选择 `name` 和 `sex` 作为匹配列，扫描所有满足条件的数据行，然后将 `age` 当做过滤列 (Filtering Column) 。过滤列虽然不能够减少索引片的大小，但是能够减少从表中随机读取数据的次数，所以在索引中也扮演着非常重要的角色。

![](../../img/cloud/index-opt10.png)


[slide]
# 3. 索引的设计

[slide]
# 3.1 三星索引
三星索引是对于一个查询语句可能的最好索引，如果一个查询语句的索引是三星索引，那么它只需要进行一次磁盘的随机读及一个窄索引片的顺序扫描就可以得到全部的结果集；因此其查询的响应时间比普通的索引会少几个数量级；主键索引对于 `WHERE id = 1` 就是一个特殊的三星索引，只需要对主键索引树进行一次索引访问并且顺序读取一条数据记录查询就结束了。

![](../../img/cloud/index-opt11.png)


[slide]
三星索引中的三颗星，需要满足下面条件：

- 第一颗星需要取出所有等值谓词中的列，作为索引开头的最开始的列（任意顺序）；
- 第二颗星需要将 `ORDER BY` 列加入索引中；
- 第三颗星需要将查询语句剩余的列全部加入到索引中；

[slide]
如果对于一个查询语句我们依照上述的三个条件进行设计，那么就可以得到该查询的三星索引，这三颗星中的最后一颗星往往都是最容易获得的，满足第三颗星的索引也就是上面提到的宽索引，能够避免大量的随机 IO，如果我们遵循这个顺序为一个 SQL 查询设计索引那么我们就可以得到一个完美的索引了。


[slide]
这三颗星的并不简单，每一颗星都有自己的意义：

- 第一颗星不只是将等值谓词的列加入索引，它的作用是减少索引片的大小以减少需要扫描的数据行；
- 第二颗星用于避免排序，减少磁盘 IO 和内存的使用；
- 第三颗星用于避免每一个索引对应的数据行都需要进行一次随机 IO 从聚集索引中读取剩余的数据；

![](../../img/cloud/index-opt12.png)

[slide]
# 3.2 实例分析
在实际场景中，问题往往没有这么简单，虽然可以总能够通过宽索引避免大量的随机访问，但是在一些复杂的查询中我们无法同时获得第一颗星和第二颗星。

```sql
SELECT id, name, age FROM users
WHERE age BETWEEN 18 AND 21 AND city = "Beijing"
ORDER BY name;
```

[slide]
在上述查询中，总可以通过增加索引中的列以获得第三颗星，但是如果想要获得第一颗星就需要最小化索引片的大小，这时索引的前缀必须为 `(city, age)`，在这时再想获得第三颗星就不可能了，哪怕在 `age` 的后面添加索引列 `name` ，也会因为 `name` 在范围索引列 `age` 后面必须进行一次排序操作，最终得到的索引就是 1：

![](../../img/cloud/index-opt13.png)


[slide]
如果我们需要在内存中避免排序的话，就需要交换 `age` 和 `name` 的位置了，在这时就可以得到索引 `(city, name, age, id)`，当一个 SQL 查询中同时拥有范围谓词和 `ORDER BY` 时，无论如何我们都是没有办法获得一个三星索引的，我们能够做的就是在这两者之间做出选择，是牺牲第一颗星还是第二颗星。


[slide]
总而言之，在设计单表的索引时，首先把查询中所有的等值谓词全部取出以任意顺序放在索引最前面，在这时，如果索引中同时存在范围索引和 `ORDER BY` 就需要权衡利弊了，希望最小化扫描的索引片厚度时，应该将过滤因子最小的范围索引列加入索引，如果希望避免排序就选择 `ORDER BY` 中的全部列，在这之后就只需要将查询中剩余的全部列加入索引了，通过这种固定的方法和逻辑就可以最快地获得一个查询语句的二星或者三星索引了。


[slide]
# 4. 索引性能分析

[slide]
# 4.1 基本问题法
当我们需要考虑对现有的 `SELECT` 查询进行分析时，哪怕没有足够的时间，也应该使用基本问题法对查询进行评估，评估的内容非常简单：现有的索引或者即将添加的索引是否包含了 `WHERE` 中使用的全部列，也就是对于当前查询来说，是否有一个索引是半宽索引。

![](../../img/cloud/index-opt14.png)

[slide]
窄索引` (username) `其实就叫做半宽索引，其中包含了 WHERE 中的全部的列 username，当前索引的对于该查询只有一颗星，它虽然避免了无效的回表查询造成的随机 IO，但是如果当前的索引的性能仍然无法满足需要，就可以添加 age 将该索引变成宽索引 `(username, age)` 以此来避免回表访问造成的性能影响；对于上图中的简单查询，索引` (username, age) `其实已经是一个三星索引了，但是对于包含` ORDER BY `或者更加复杂的查询，`(username, age) `可能就只是二星索引：在这时如果该索引仍然不能满足性能的需要，就可以考虑重新设计了。

![](../../img/cloud/index-opt15.png)


[slide]
虽然基本问题法能够快速解决一些由于索引造成的问题，但是它并不能保证足够的性能，当表中有 `(city, username, age)`索引，谓词为 `WHERE username="draveness" AND age="21"` 时，使用基本问题法并不能得出正确的结果。

[slide]
# 4.2 快速估算上限法
基本问题法非常简单，它能够最短的时间内帮助我们评估一个查询的性能，但是它并不能准确地反映一个索引相关的性能问题，而快速估算上限法就是一种更加准确、复杂的方法了；其目的在于在程序开发期间就能将访问路径缓慢的问题暴露出来，这个估算方法的输出就是本地响应时间（Local Response Time）：本地响应时间就是查询在数据库服务器中的耗时，不包括任何的网络延迟和多层环境的通信时间，仅包括执行查询任务的耗时。

![](../../img/cloud/index-opt16.png)

[slide]
# 响应时间
本地响应时间等于服务时间和排队时间的总和，一次查询请求需要在数据库中等待 CPU 以及磁盘的响应，也可能会因为其他事务正在对同样的数据进行读写，导致当前查询需要等待锁的获取，不过组成响应时间中的主要部分还是磁盘的服务时间：

![](../../img/cloud/index-opt17.png)


[slide]
`QUBE` 在计算的过程中会忽略除了磁盘排队时间的其他排队时间，这样能够简化整个评估流程，而磁盘的服务时间主要还是包括同步读写以及异步读几个部分：

![](../../img/cloud/index-opt18.png)


[slide]
在排除了上述多个部分的内容，我们得到了一个非常简单的估算过程，整个估算时间的输入仅为随机读和顺序读以及数据获取的三个输入，而它们也是影响查询的主要因素：

![](../../img/cloud/index-opt19.png)


[slide]
其中数据获取的过程在比较不同的索引对同一查询的影响是不需要考虑的，因为同一查询使用不同的索引也会得到相同的结果集，获取的数据也是完全相同的。

[slide]
# 访问
当数据库读取一个索引行或者一个表行时，就会发生一次访问，当使用全表扫描或者扫描索引片时，读取的第一个行就是随机访问，随机访问需要磁盘进行寻道和旋转，所以其代价巨大，而接下来顺序读取的所有行都是通过顺序访问读取的，代价只有随机访问的千分之一。 如果大量的顺序读取索引行和表行，在原理上可能会造成一些额外的零星的随机访问，不过这对于整个查询的估算来说其实并不重要；在计算本地响应时间时，仍然会把它们当做顺序访问进行估算。

[slide]
# 示例
在这里，我们简单地举一个例子来展示如何计算查询在使用某个索引时所需要的本地响应时间，假设我们有一张 `users` 表，其中有一千万条数据：

![](../../img/cloud/index-opt20.png)

[slide]
在该 `users` 表中除了主键索引之外，还具有以下 `(username, city)`、`(username, age)` 和 `(username)` 几个辅助索引，当我们使用如下所示的查询时：

![](../../img/cloud/index-opt21.png)

[slide]
两个查询条件分别有着 `0.05%` 和 `12%` 的过滤因子，该查询可以直接使用已有的辅助索引 `(username, city)`，接下来我们根据表中的总行数和过滤因子开始估算这一步骤 SQL 的执行时间：

![](../../img/cloud/index-opt22.png)


[slide]
该查询在开始时会命中` (username, city) `索引，扫描符合条件的索引片，该索引总共会访问 `10,000,000 * 0.05% * 12% = 600` 条数据，其中包括 1 次的随机访问和 599 次的顺序访问，因为该索引中的列并不能满足查询的需要，所以对于每一个索引行都会产生一次表的随机访问，以获取剩余列 `age` 的信息：

![](../../img/cloud/index-opt23.png)


[slide]
在这个过程中总共产生了 `600` 次随机访问，最后取回结果集的过程中也会有 `600` 次 `FETCH` 操作，从总体上来看这一次 SQL 查询共进行了 `601` 次随机访问、 `599` 次顺序访问和 `600` 次 FETCH，根据上一节中的公式我们可以得到这个查询的用时约为 `6075.99ms` 也就是 `6s` 左右，这个时间对于绝大多数应用都是无法接受的。

![](../../img/cloud/index-opt24.png)


[slide]
在整个查询的过程中，回表查询的 `600` 次随机访问成为了这个超级慢的查询的主要贡献，为了解决这个问题，我们只需要添加一个 `(username, city, age)` 索引或者在已有的 `(username, city)` 后添加新的 `age` 列就可以避免 `600` 次的随机访问，`(username, city, age)` 索引对于该查询其实就是一个三星索引了。

![](../../img/cloud/index-opt25.png)